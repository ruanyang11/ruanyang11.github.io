<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>makefile语法解析</title>
      <link href="/2024/03/20/makefile%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/03/20/makefile%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/ry2001/img/raw/master/202403201607431.png" alt="image-20240320160728268"></p><h1 id="一-GCC"><a href="#一-GCC" class="headerlink" title="一.GCC"></a>一.GCC</h1><blockquote><p>Reference:</p><p>正点原子</p></blockquote><h2 id="1-1-gcc安装"><a href="#1-1-gcc安装" class="headerlink" title="1.1 gcc安装"></a>1.1 gcc安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><h2 id="1-2-gcc指令格式"><a href="#1-2-gcc指令格式" class="headerlink" title="1.2 gcc指令格式"></a>1.2 gcc指令格式</h2><blockquote><p>gcc  [选项]  [文件名字] </p><p>主要[选项]如下： </p><p><strong>-c</strong>：只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。 </p><p><strong>-o</strong>：&lt;输出文件名&gt;用来指定编译结束以后的输出文件名，如果不使用这个选项的话 GCC 默 </p><p>认编译出来的可执行文件名字为 a.out。 </p><p><strong>-g</strong>：添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编 </p><p>译的时候生成调试所需的符号信息。 </p><p><strong>-O</strong>：对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进 </p><p>行优化，这样产生的可执行文件执行效率就高。 </p><p><strong>-O2</strong>：比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。</p></blockquote><h2 id="1-3-GCC编译c文件"><a href="#1-3-GCC编译c文件" class="headerlink" title="1.3 GCC编译c文件"></a>1.3 GCC编译c文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure><p>​这时在此文件的根目录下生成一个<code>.out</code>文件，这个.out文件就是编译生成的可执行文件，执行的方法很简单使用命令“.&#x2F;+可执行文件”。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure><p>​使用<code>gcc hello.c -o hello </code>来编译hello.c文件，使用参数<code>-o</code>来指定编译生成的可执文件名字，此外编译hello.c文件除了<code>gcc hello.c -o hello</code>格式之外，还可以写成<code>gcc -o hello hello.c</code>的命令格式，hello.c所处位置，不会影响编译最后的结果。</p><h2 id="1-4-GCC编译器的编译流程"><a href="#1-4-GCC编译器的编译流程" class="headerlink" title="1.4 GCC编译器的编译流程"></a>1.4 GCC编译器的编译流程</h2><p>​当输入指令<code>gcc hello.c -o hello</code>编译hello.c文件时实际上经历了四个流程：预处理、编译、汇编和链接。预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中。编译是将经过预编译处理的代码编译成汇编 代码，也就是我们常说的程序编译。汇编就是将汇编语言文件编译成二进制目标文件。链接就 是将汇编出来的多个二进制目标文件链接在一起，形成最终的可执行文件，链接的时候还会涉及到静态库和动态库等问题。</p><h3 id="1-4-1-预处理"><a href="#1-4-1-预处理" class="headerlink" title="1.4.1 预处理"></a>1.4.1 预处理</h3><p>​预处理(-E):预处理指定的源文件，但不进行编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure><p>​预处理器会将源代码中所有以“#”开头的指令进行处理，例如#include、#define、#ifdef等等。其中，#include指令会将指定的头文件内容插入到当前文件中，#define指令会将指定的宏定义替换为对应的值，#ifdef指令会根据条件判断是否编译某段代码。预编译通常输出的是一个预处理文件，通常以.i作为文件扩展名。</p><h3 id="1-4-2-编译"><a href="#1-4-2-编译" class="headerlink" title="1.4.2 编译"></a>1.4.2 编译</h3><p> 编译(-S):编译可执行文件，但不进行汇编</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S main.i -o main,s</span><br></pre></td></tr></table></figure><p>编译过程是将预处理文件编译成汇编代码。编译器输出的是一个汇编代码文件，通常以.s作为文件扩展名。</p><h3 id="1-4-3-汇编"><a href="#1-4-3-汇编" class="headerlink" title="1.4.3 汇编"></a>1.4.3 汇编</h3><p>汇编(-c):汇编，汇编指定的源文件，但不进行链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c main.s -o main.o</span><br></pre></td></tr></table></figure><p>GCC的汇编过程是将汇编代码转化成机器指令。汇编器输出得到是一个目标文件，通常以.o为文件扩展名。</p><h3 id="1-4-4-链接"><a href="#1-4-4-链接" class="headerlink" title="1.4.4 链接"></a>1.4.4 链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main. o -o main</span><br></pre></td></tr></table></figure><p>​GCC的链接过程是将<strong>多个目标文件和库文件</strong>合并成一个<strong>可执行文件</strong>的过程。在编译过程中，源代码被编译成目标文件，每个目标文件包含了一部分程序的机器代码和数据。链接器将这些目标文件合并在一起，解决符号引用，生成最终的可执行文件。</p><p>​链接过程分为静态链接和动态链接两种方式。静态链接是将所有目标文件和库文件的代码和数据合并到一个可执行文件中，这样生成的可执行文件可以在没有库文件的情况下独立运行。动态链接是将程序运行所需的库文件链接到可执行文件中，在程序运行时动态加载这些库文件。</p><p>链接过程主要完成以下几个任务：</p><ol><li><p><strong>解析符号引用：</strong>在多个目标文件中可能存在相同的符号，例如函数、变量等。链接器会将这些符号引用解析为符号定义，以便生成正确的可执行文件。</p></li><li><p><strong>合并代码和数据：</strong>链接器将多个目标文件中的代码和数据合并到一个可执行文件中，生成一个完整的程序。</p></li><li><p><strong>重定位：</strong>当代码和数据被合并到可执行文件中时，链接器会对它们进行重定位，以确保它们能够正确地访问地址空间中的其他部分。</p></li><li><p><strong>动态链接：</strong>在动态链接的情况下，链接器会将程序运行所需的库文件链接到可执行文件中。在程序运行时，操作系统会动态加载这些库文件，以便程序能够正常运行。</p></li></ol><p>​在GCC中，可以使用命令行选项<code>-o</code>指定输出文件名，例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.o world.o</span><br></pre></td></tr></table></figure><p>​这个命令会将hello.o和world.o两个目标文件链接在一起，生成可执行文件hello。如果需要链接库文件，可以使用命令行选项“-l”（小写l）指定库文件名，例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.o -lm</span><br></pre></td></tr></table></figure><p>​这个命令会将数学库文件libm.a链接到可执行文件hello中。</p><p>​指定头文件路径，一般都是通过<code>-I</code>（大写的i）来指定，假头文件存在：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/hello</span><br></pre></td></tr></table></figure><p>​可以通过-I指定</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-I /home/hello</span><br></pre></td></tr></table></figure><h1 id="二-Makefile"><a href="#二-Makefile" class="headerlink" title="二.Makefile"></a>二.Makefile</h1><p>​Makefile里面是一系列的规则组成的，这些规则格式如下：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab] &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>​上述参数“target”叫做目标，冒号后面的部分叫做“前置条件”；第二行必须由一个tab键起首，后面跟着命令。”目标“是必须的，不可省略的； ”前置条件“和”命令都是可选的“，但两者之间必须至少存在一个。 </p><p>比如下面这条规则</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main : main.o input.o calcu.o </span><br><span class="line">    gcc -o main main.o input.o calcu.o</span><br></pre></td></tr></table></figure><p>​这条规则的目标是 <code>main，main.o、input.o 和 calcu.o</code> 是生成 main 的依赖文件，如果要更新目标 main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表。 </p><p><strong>命令列表中的每条命令必须以 TAB 键开始，不能使用空格！</strong> </p><p>​make 命令会为 Makefile 中的每个以 TAB 开始的命令创建一个 Shell 进程去执行。</p><p>Makefile代码示例：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o </span></span><br><span class="line">gcc -o main maino inpu.o calcu.o </span><br><span class="line"><span class="section">main.o: main.c </span></span><br><span class="line">    gcc -c main.c </span><br><span class="line"><span class="section">input.o: input.c </span></span><br><span class="line">    gcc -c input.c </span><br><span class="line"><span class="section">calcu.o: calcu.c </span></span><br><span class="line">    gcc -c calcu.c </span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">    rm .o </span><br><span class="line">    rm main</span><br></pre></td></tr></table></figure><p>​       上述代码中一共有 5 条规则，1<del>2 行为第一条规则，3</del>4 行为第二条规则，5<del>6 行为第三条规则，7</del>8 行为第四条规则，10~12 为第五条规则，make 命令在执行这个 Makefile 的时候其执行步骤如下： </p><p>​        首先更新第一条规则中的 main，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为 Makefile 的工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行，第一条规则依赖于文件 <code>main.o</code>、<code>input.o </code>和<code>calcu.o</code> 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make 会查找以这三个.o 文件为目标的规则并执行。以 <code>main.o</code>为例，发现更新 <code>main.o </code>的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为<code>gcc -c main.c</code>，这行命令很熟悉了吧，就是不链接编译 <code>main.c</code>，生成 <code>main.o</code>，其它两个<code>.o </code>文件同理。 </p><p>​        最后一个规则目标是 clean，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令<code>make clean</code>，执行以后就会删 </p><p>除当前目录下所有的<code>.o </code>文件以及<code> main</code>，因此<code>clean</code>的功能就是完成工程的清理。</p><p>​       如果make指令没有指定目标，默认会执行makefile文件中的第一个目标。</p><p><strong>make指令执行过程：</strong></p><p>我们在来总结一下 Make 的执行过程： </p><ol><li>make 命令会在当前目录下查找以 Makefile(makefile 其实也可以)命名的文件。 </li><li>当找到 Makefile 文件以后就会按照 Makefile 中定义的规则去编译生成最终的目标文件。 </li><li>当发现目标文件不存在，或者目标所依赖的文件比目标文件新(也就是最后修改时间比</li></ol><p>目标文件晚)的话就会执行后面的命令来更新目标</p><h2 id="2-1-Makefile伪目标"><a href="#2-1-Makefile伪目标" class="headerlink" title="2.1 Makefile伪目标"></a>2.1 Makefile伪目标</h2><p>​        Makefile 有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行 make 命令的时候通过指定这个伪目标来执行其所在规则的定义的命令。 </p><p>​       使用伪目标主要是为了避免 Makefile 中定义的执行命令的目标和工作目录下的实际文件出现名字冲突，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面的示例代码中有如下代码用来完成清理工程的功能： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean: </span><br><span class="line">    rm *.o </span><br><span class="line">    rm main </span><br></pre></td></tr></table></figure><p>​      上述规则中并没有创建文件 clean 的命令，因此工作目录下永远都不会存在文件 clean，当我们输入<code>make clean</code>以后，后面的<code>rm *.o</code>和<code>rm main</code>总是会执行。可是如果我们“手贱”，在工作目录下创建一个名为“clean”的文件，那就不一样了，当执行“make clean”的时候，规则因为没有依赖件，所以目标被认为是最新的，因此后面的 rm 命令也就不会执行，我们预先设想的清理工程的功能也就无法完成。为了避免这个问题，我们可以将 clean 声明为伪目标，声明方式如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean </span><br></pre></td></tr></table></figure><p>我们使用伪目标来更改示例代码 ，修改完成以后如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o input.o calcu.o</span><br><span class="line">main : $ ( objects )</span><br><span class="line">gcc - o main $ ( objects )</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">gcc - c $ &lt;</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><p>​上述代码第 5 行声明<code> clean</code> 为伪目标，声明 <code>clean </code>为伪目标以后不管当前目录下是否存在为<code>clean</code>的文件，输入<code>make clean</code>的话规则后面的<code>rm </code>命令都会执行。 </p><h2 id="2-2-Makefile条件判断"><a href="#2-2-Makefile条件判断" class="headerlink" title="2.2 Makefile条件判断"></a>2.2 Makefile条件判断</h2><p>​在 C 语言中我们通过条件判断语句来根据不同的情况来执行不同的分支，Makefile 也支持条件判断，语法有两种如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;条件关键字&gt; </span><br><span class="line">    &lt;条件为真时执行的语句&gt; </span><br><span class="line"><span class="keyword">endif</span> </span><br><span class="line"></span><br><span class="line">以及： </span><br><span class="line"></span><br><span class="line">&lt;条件关键字&gt; </span><br><span class="line">&lt;条件为真时执行的语句&gt; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   &lt;条件为假时执行的语句&gt; </span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span> </span><br></pre></td></tr></table></figure><p>​其中条件关键字有 4 个：ifeq、ifneq、ifdef 和 ifndef，这四个关键字其实分为两对、ifeq 与ifneq、ifdef 与 ifndef，先来看一下 ifeq 和 ifneq，ifeq 用来判断是否相等，ifneq 就是判断是否不 相等，ifeq 用法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;参数 1&gt;, &lt;参数 2&gt;) </span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> ‘&lt;参数 1 &gt;’,‘ &lt;参数 2&gt;’ </span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> “&lt;参数 1&gt;”, “&lt;参数 2&gt;” </span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> “&lt;参数 1&gt;”, ‘&lt;参数 2&gt;’ </span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> ‘&lt;参数 1&gt;’, “&lt;参数 2&gt;” </span><br></pre></td></tr></table></figure><p>​        上述用法中都是用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1”和 “参数 2”可以为函数返回值。ifneq 的用法类似，只不过 ifneq 是用来了比较“参数 1”和“参 数 2”是否不相等，如果不相等的话就为真。 </p><p>ifdef 和 ifndef 的用法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;变量名&gt; </span><br></pre></td></tr></table></figure><p>​       如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以是一个函数的返回值。ifndef 用法类似，但是含义用户 ifdef 相反</p><h2 id="2-3-Makefile函数使用"><a href="#2-3-Makefile函数使用" class="headerlink" title="2.3 Makefile函数使用"></a>2.3 Makefile函数使用</h2><p>​Makefile 支持函数，类似 C 语言一样，Makefile 中的函数是已经定义好的，我们直接使用， 不支持我们自定义函数。make 所支持的函数不多，但是绝对够我们使用了，函数的用法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(函数名 参数集合) </span><br><span class="line">或者： </span><br><span class="line">$&#123;函数名 参数集合&#125; </span><br></pre></td></tr></table></figure><p>​可以看出，调用函数和调用普通变量一样，使用符号<code>$</code>来标识。参数集合是函数的多个参数，参数之间以逗号<code>,</code>隔开，函数名和参数之间以<code>空格</code>分隔开，函数的调用以<code>$</code>开头。接下来我们介绍几个常用的函数。</p><ol><li>函数 <strong>subst</strong></li></ol><p>​函数 subst 用来完成字符串替换，调用形式如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span> </span><br></pre></td></tr></table></figure><p>​此函数的功能是将字符串<text>中的<from>内容替换为<to>，函数返回被替换以后的字符串，比如如下示例： </to></from></text></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> zzk,ZZK,my name is zzk)</span></span><br></pre></td></tr></table></figure><p>把字符串“my name is zzk”中的“zzk”替换为“ZZK”，替换完成以后的字符串为“my name is ZZK”。 </p><ol start="2"><li>函数 <strong>patsubst</strong></li></ol><p>​函数 patsubst 用来完成模式字符串替换，使用方法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span> </span><br></pre></td></tr></table></figure><p>​此函数查找字符串<code>&lt;text&gt;</code>中的单词是否符合模式<code>&lt;pattern&gt;</code>，如果匹配就用<code>&lt;replacement&gt;</code>来替换掉，<code>&lt;pattern&gt;</code>可以使用通配符“%”，表示任意长度的字符串，函数返回值就是替换后的字符串。如果<code>&lt;replacement&gt;</code>中也包涵“%”，那么<code>&lt;replacement&gt;</code>中的“%”将是<code>&lt;pattern&gt;</code>中的那个 </p><p>“%”所代表的字符串，比如： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,a.c b.c c.c)</span> </span><br></pre></td></tr></table></figure><p>​将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字 符串为“a.o b.o c.o”。 </p><ol start="3"><li>函数 <strong>dir</strong></li></ol><p>​函数 dir 用来获取目录，使用方法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names…&gt;)</span> </span><br></pre></td></tr></table></figure><p>​此函数用来从文件名序列<code>&lt;names&gt;</code>中提取出目录部分，返回值是文件名序列<code>&lt;names&gt;</code>的目录部分，比如： </p><p><code>$(dir &lt;/src/a.c&gt;) </code></p><p>​提取文件“&#x2F;src&#x2F;a.c”的目录部分，也就是“&#x2F;src”。 </p><ol start="4"><li>函数<strong>notdir</strong></li></ol><p>​函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names…&gt;)</span> </span><br></pre></td></tr></table></figure><p>​此函数用与从文件名序列<names>中提取出文件名非目录部分，比如： <code>$(notdir &lt;/src/a.c&gt;) </code></names></p><p>​提取文件“&#x2F;src&#x2F;a.c”中的非目录部分，也就是文件名“a.c”。 </p><ol start="5"><li>函数 <strong>foreach</strong></li></ol><p>foreach 函数用来完成循环，用法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)</span> </span><br></pre></td></tr></table></figure><p>​此函数的意思就是把参数<code>&lt;list&gt;</code>中的单词逐一取出来放到参数<code>&lt;var&gt;</code>中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每次<code>&lt;text&gt;</code>都会返回一个字符串，循环的过程中，<code>&lt;text&gt;</code>中所包含的每个字符串会以空格隔开，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串将会是函数<code>foreach</code>函数的返回值。 </p><ol start="6"><li>函数 <strong>wildcard</strong></li></ol><p>​通配符“%”只能用在规则中，只有在规则中它才会展开，如果在变量定义和函数使用时，通配符不会自动展开，这个时候就要用到函数 wildcard，使用方法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN…)</span> </span><br></pre></td></tr></table></figure><p>比如： </p><p><code>$(wildcard *.c) </code></p><p>上面的代码是用来获取当前目录下所有的<code>.c</code> 文件，类似<code>%</code>。 </p><h2 id="2-4-Makefile变量"><a href="#2-4-Makefile变量" class="headerlink" title="2.4 Makefile变量"></a>2.4 Makefile变量</h2><p>​跟 C 语言一样 Makefile 也支持变量的，先看一下前面的例子： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o input.o calcu.o </span></span><br><span class="line">gcc -o main main.o input.o calcu.o </span><br></pre></td></tr></table></figure><p>​       上述 Makefile 语句中，<code>main.o input.o 和 calcue.o</code> 这三个依赖文件，我们输入了两遍，我们这个 Makefile 比较小，如果 Makefile 复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile 加入了变量支持。不像 C 语言中的变量有 int、char等各种类型，Makefile 中的变量都是字符串！类似 C 语言中的宏。使用变量将上面的代码修改， </p><p>修改以后如下所示： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 Makefile 变量使用 </span><br><span class="line"><span class="comment">#Makefile 变量的使用 </span></span><br><span class="line">objects = main.o input.o calcu.o </span><br><span class="line"></span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span> </span></span><br><span class="line">gcc -o main <span class="variable">$(objects)</span> </span><br></pre></td></tr></table></figure><p>​        我们来分析一下示例代码 ，第 1 行是注释，Makefile 中可以写注释，注释开头要用符号“#”，不能用 C 语言中的<code>//</code>或者<code>/**/</code>！第 2 行我们定义了一个变量 objects，并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4行使用到了变量 objects，Makefile 中变量的引用方法是<code>$(变量名)</code>，比如本例中的<code>$(objects)</code>就是使用变量 objects。</p><p>在“示例代码”中我们在定义变量 objects 的时候使用<code>=</code>对其进行了赋值，Makefile变量的赋值符还有其它两个<code>:=</code>和<code>?=</code>，我们来看一下这三种赋值符的区别： </p><ol><li><strong>赋值符“&#x3D;”</strong></li></ol><p>​使用“&#x3D;”在给变量的赋值的时候，不一定要用已经定义好的值，也可以使用后面定义的值， </p><p>比如如下代码： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 赋值符<span class="string">&quot;=&quot;</span>使用</span><br><span class="line">name = zzk</span><br><span class="line">curname = <span class="variable">$(name)</span></span><br><span class="line">name = zuozhongkai</span><br><span class="line">print :</span><br><span class="line">@echo curname : <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure><p>​我们来分析一下上述代码，第 1 行定义了一个变量 name，变量值为“zzk”，第 2 行也定义了一个变量curname，curname的变量值引用了变量name，按照我们C写语言的经验此时curname的值就是“zzk”。第 3 行将变量 name 的值改为了“zuozhongkai”，第 5、6 行是输出变量 curname的值。在 Makefile 要输出一串字符的话使用<code>echo</code>，就和 C 语言中的<code>printf</code>一样，第 6 行中的“echo”前面加了个<code>@</code>符号，因为 Make 在执行的过程中会自动输出命令执行过程，在命令前面加上“@”的话就不会输出命令执行过程，大家可以测试一下不加“@命令<code>make print</code>来执行上述代码，如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403201609270.png" alt="img"></p><p>​在上图中可以看到curname的值不是“zzk”，竟然是“zuozhongkai”，也就是变量“name” 最后一次赋值的结果，这就是赋值符“&#x3D;”的神奇之处！借助另外一个变量，可以将变量的真实 值推到后面去定义。也就是变量的真实值取决于它所引用的变量的最后一次有效值。</p><ol start="2"><li><strong>赋值符“:&#x3D;”</strong></li></ol><p>​代码如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 <span class="string">&quot;:=&quot;</span>的使用</span><br><span class="line">name = zzk</span><br><span class="line">curname := <span class="variable">$(name)</span></span><br><span class="line">name = zuozhongkai</span><br><span class="line">print :</span><br><span class="line">@echo curname : $ (curname)</span><br></pre></td></tr></table></figure><p>​修改完成以后重新执行一下 Makefile，结果如图  所示： </p><p><img src="https://gitee.com/ry2001/img/raw/master/202403201610973.png" alt="img"></p><p>​从上图 中可以看到此时的 curname 是 zzk，不是 zuozhongkai 了。这是因为赋值符“:&#x3D;”不会使用后面定义的变量，只能使用前面已经定义好的，这就是“&#x3D;”和“:&#x3D;”两个的区别。</p><p><strong>3</strong>、赋值符“**?&#x3D;**”</p><p>​ “?&#x3D;”是一个很有用的赋值符，比如下面这行代码： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">curname ?= zuozhongkai </span><br></pre></td></tr></table></figure><p>​上述代码的意思就是，如果变量 curname 前面没有被赋值，那么此变量就是“zuozhongkai”，如果前面已经赋过值了，那么就使用前面赋的值。 </p><p><strong>4</strong>、变量追加“**+&#x3D;**”</p><p>​Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量添加一些字符串进去，此时就要使用到符号“+&#x3D;”，比如如下所示代码： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o inpiut.o </span><br><span class="line">objects += calcu.o </span><br></pre></td></tr></table></figure><p>​一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此变量 objects 变成了“main.o input.o calcu.o”，这个就是变量的追加。 </p><h3 id="2-4-1-Makefile-模式规则"><a href="#2-4-1-Makefile-模式规则" class="headerlink" title="2.4.1 Makefile 模式规则"></a><strong>2.4.1 Makefile</strong> <strong>模式规则</strong></h3><p>​    在前面我们编写了一个 Makefile 文件用来编译工程，这个 Makefile 的内容如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 Makefile 文件代码</span><br><span class="line">main : main.o input.o calcu.o</span><br><span class="line">gcc -o main main.o input.o calcu.o</span><br><span class="line">main.o : main .c</span><br><span class="line">gcc -c main .c</span><br><span class="line">input.o : input .c</span><br><span class="line">gcc -c input .c</span><br><span class="line">calcu.o : calcu.c</span><br><span class="line">gcc -c calcu .c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><p>​上述 Makefile 中第 3~8 行是将对应的.c 源文件编译为<code>.o </code>文件，每一个 C 文件都要写一个对应的规则，如果工程中 C 文件很多的话显然不能这么做。为此，我们可以使用 Makefile 中的模式规则，通过模式规则我们就可以使用一条规则来将所有的<code>.c </code>文件编译为对应的<code>.o </code>文件。模式规则中，至少在规则的目标定定义中要包涵“%”，否则就是一般规则，目标中的“%” 表示对文件名的匹配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件，类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件。当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值，使用方法如下： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c </span><br></pre></td></tr></table></figure><p>​因此“示例代码 ”中的 Makefile 可以改为如下形式： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 模式规则使用</span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line">main : <span class="variable">$(objects)</span></span><br><span class="line">gcc -o main <span class="variable">$(object )</span></span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line"> <span class="comment"># 命令</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><h2 id="2-5-Makefile自动化变量"><a href="#2-5-Makefile自动化变量" class="headerlink" title="2.5 Makefile自动化变量"></a>2.5 Makefile自动化变量</h2><p>​上面讲的模式规则中，目标和依赖都是一系列的文件，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而命令只有一行，如何通过一行命令来从不同的依赖文件中生成对应的目标？自动化变量就是完成这个功能的！所谓自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完，自动化变量只应该出现在规则的命令中，常用的自动化变量如表 ：</p><table><thead><tr><th>自动化变量</th><th>描述</th></tr></thead><tbody><tr><td>$@</td><td>规则中的目标集合，在模式规则中，如果有多个目标的话，“ $@ ”表示匹配模式中定义的目标集合。</td></tr><tr><td>$%</td><td>当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。</td></tr><tr><td>$&lt;</td><td>依赖文件集合中的第一个文件，如果依赖文件是以模式 ( 即“ % ” ) 定义的，那么“$&lt; ”就是符合模式的一系列的文件集合。</td></tr><tr><td>$?</td><td>所有比目标新的依赖目标集合，以空格分开。</td></tr><tr><td>$^</td><td>所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，“$^ ”会去除重复的依赖文件，值保留一份。</td></tr><tr><td>$+</td><td>和“ $^ ”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。</td></tr><tr><td>$*</td><td>这个变量表示目标模式中 “%” 及其之前的部分，如果目标是 test&#x2F;a.test.c ，目标模式为 a.%.c ，那么“ $* ”就是 test&#x2F;a.test 。</td></tr></tbody></table><p>​       表中的 7 个自动化变量中，常用的三种：$@、$&lt;和$^，我们使用自动化变量来完成“示例代码 ”中的 Makefile，最终的完整代码如下所示： </p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例代码 自动化变量</span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line">main : <span class="variable">$(objects)</span></span><br><span class="line">        gcc -o main <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">gcc -c $ &lt;</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">rm *.o</span><br><span class="line">rm main</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32的智能循迹避障小车</title>
      <link href="/2024/03/18/%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E6%99%BA%E8%83%BD%E5%BE%AA%E8%BF%B9%E9%81%BF%E9%9A%9C%E5%B0%8F%E8%BD%A6/"/>
      <url>/2024/03/18/%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E6%99%BA%E8%83%BD%E5%BE%AA%E8%BF%B9%E9%81%BF%E9%9A%9C%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="一、-智能循迹避障系统概述"><a href="#一、-智能循迹避障系统概述" class="headerlink" title="一、 智能循迹避障系统概述"></a>一、 智能循迹避障系统概述</h1><p>​    本文所述的基于STM32控制器的智能循迹避障小车主要由车体、电池模块、主控制器、外接电路扩展板、电机驱动模块、电机、红外对管传感器模块、OpenMV摄像头、碰撞传感器、测距传感器、LCD显示屏等组成，具体结构图如下图所示。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191348951.png" alt="img"></p><p>​    智能循迹避障小车，具有感知能力和判断逻辑能力，可以智能化地识别轨道信息并做出相应判断。小车循迹功能主要由OpenMV 摄像头模块负责，利用OpenMV进行直线的循迹，并进行转弯和刹车。OpenMV采用线性回归的方式进行巡线，摄像头会将一帧一帧的图像进行处理，得到二值化图像，获取线性回归直线，并得到直线的角度和相对偏移量，此时我们把相对偏移量通过串口发送到STM32进行数据分析，微处理器分析数据后进行脉冲计算，产生PWM波形和占空比信息；智能寻迹小车控制系统常见的控制指标是速度和路径判断的精度，还要考虑突发状况下的应急反应处理能力和避障能力，小车的避障功能用超声波模块HC_SR04和微动开关实现，小车的转速、电量等参数都会通过串口发送至LABVIEW上位机进行显示，并能通过上位机LABVIEW对小车发出指令操作。</p><p>​    小车循迹H型赛道如图2所示，依次到达ABC三点后返回起点。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191348966.png" alt="img"></p><p>​    对于ABC三点的循迹，采用分段路径规划的方法完成。路径一：从起点到A点，A点设有障碍物，用于设置到达A点时停止位置；路径二：从A点到B点，在A点到B点过程中，会经过两个路口，小车在两个路口都需要实现转弯操作，因此在OpenMV基础上配一个红外该对管循迹模块，来完成转向操作，路径三：B点到C点，此时执行直线操作；路径四：C点到起点，同样经过两个路口，小车在两个路口都需要实现转弯操作，至此，小车完成整个H形轨迹循迹。</p><h1 id="二-、系统硬件设计与选型"><a href="#二-、系统硬件设计与选型" class="headerlink" title="二.、系统硬件设计与选型"></a>二.、系统硬件设计与选型</h1><h2 id="2-1-微处理器选择"><a href="#2-1-微处理器选择" class="headerlink" title="2.1 微处理器选择"></a>2.1 微处理器选择</h2><p>​    从性能、功耗以及外设资源等方面考虑：STM32F407在168 MHz频率下，从Flash存储器执行时，能够提供210 DMIPS&#x2F;566 CoreMark性能，并且利用意法半导体的ART加速器实现了Flash零等待状态，并且在90 nm工艺和ART加速器加持下，具有动态功耗调整功能，能够在运行模式下和从Flash存储器执行时实现低至238 µA&#x2F;MHz的电流消耗，同时外设资源丰富，满足实验要求，后期可扩展性强，另外DSP指令和浮点单元扩大了产品的应用范围。</p><h2 id="2-2-循迹模块选择"><a href="#2-2-循迹模块选择" class="headerlink" title="2.2 循迹模块选择"></a>2.2 循迹模块选择</h2><p>​    一般简易式循迹小车通过单一传感器来获取寻迹的迹线信息，容易出现小车信息采集不完整，当小车行驶到较为复杂的路况时，例如S型或者T型轨迹时会出现车辆偏离预定轨迹的情况，另外寻迹小车的运行环境太亮或者太暗，会干扰红外传感器接受红外线的灵敏度，而OpenMV摄像头处在自动识别模式下可以避免光线环境的影响，因此本设计选用OpenMV摄像传感器完成循迹功能。</p><img src="https://gitee.com/ry2001/img/raw/master/202403191348468.png" alt="img" style="zoom:50%;"><p>​    OpenMV摄像头传感器是用Python语言编程的可编程摄像头，在OpenMV的函数库里，拥有大量的内置图像算法函数，只需要理解每个函数的用法以及返回的值，就可以使用该模块。</p><p>​    OpenMV循迹原理：OpenMV与STM32采用串口的方式进行传参。OpenMV采用线性回归的方式进行巡线，将摄像头得到的帧图像进行二值化图像处理，获取线性回归直线，并计算直线的角度和相对偏移量，把相对偏移量通过串口发送到STM32，利用PID算法计算参数，并将参数合理的转换成小车的速度，以达到控制小车循迹的目的。</p><h2 id="2-3-避障模块选择"><a href="#2-3-避障模块选择" class="headerlink" title="2.3 避障模块选择"></a>2.3 避障模块选择</h2><p>​    循迹小车通过带有长柄的微动开关来检测循迹小车是否碰到物体，当微动开关被按下的时候，其中两个引脚会短路，一个引脚会接地，一个引脚会于处理器的IO口连接，其中与处理器IO口相连接的引脚会与一个上拉电阻进行连接，当循迹小车未遇到障碍物时，微动开关未被触发，此时对应IO口检测的会是高电平，当小车碰撞到障碍物时，触发微动开关，此时引脚会读取电平为低电平，小车左右两边都搭载了微动开关，通过判断两个微动开关输出的电平，可判断小车是哪一测遇到了障碍物，并进行调整。同时循迹小车上搭载了一个超声波模块HC_SR04，用于循迹避障，当小车距离障碍物30cm时，小车开始进行避障报警。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191349116.png" alt="img"></p><h2 id="2-4电机驱动模块"><a href="#2-4电机驱动模块" class="headerlink" title="2.4电机驱动模块"></a>2.4电机驱动模块</h2><h3 id="2-4-1-电机的选取"><a href="#2-4-1-电机的选取" class="headerlink" title="2.4.1 电机的选取"></a>2.4.1 电机的选取</h3><p>​    小车采用的电机类型是N20直流减速电机，在电机的机尾搭载了一个霍尔编码器，由霍尔马盘和霍尔元件组成。霍尔马盘是在一定直径的圆板上等分的布置有不同的磁极。霍尔马盘与电动机同轴，电动机旋转时，霍尔元件检测输出若干脉冲信号，为判断转向，可计算输出两相方波信号的相位差。霍尔元件及控制电机转速端子由六个端子组成，其中两个端子接电源和地，分别是2、3端子，1、6端子用来控制小车的速度、前进或后退，如果我们想要计算小车单位时间内转的圈数以及是正转状态还是反转状态就要通过A、B相两个输出端子输出的电平来加以判断，A相输出端子和B相输出端子两者每圈输出的电平数量是一样的，唯一不同的是，他们的相位不相同，正是因为相位不同，我们可以检测出当前轮子是正转还是反转，当正转时，A相的相位领先B相相位90°，反转时，A相的相位落后B相相位90°，通过比较AB两相的相位差即可得到当前小车的状态。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191349051.png" alt="img"></p><h3 id="2-4-2-电机驱动芯片选择以及驱动原理"><a href="#2-4-2-电机驱动芯片选择以及驱动原理" class="headerlink" title="2.4.2 电机驱动芯片选择以及驱动原理"></a>2.4.2 电机驱动芯片选择以及驱动原理</h3><p>​    在智能循迹小车中，我们采用了L293集成电机驱动芯片，L293 内部使用三极管作为电子开关，集成了三极管驱动，包含了 2 组 H 桥，可以同时控制两个电机的转速和方向，非常适合在智能车模型中使用。通过给电机的两个出入引脚不同的电平，即可驱动小车运动，当两个输入电平压差越大，小车的转速越快，输入电平越小，小车转速越慢，输入电平的压差不一样，小车运动速度也就不一样，如原理图所示。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191349945.png" alt="img"></p><p>​    寻迹小车所用电机是直流减速电机，比较好控制，通过给电机的两个出入引脚不同的电平，即可驱动小车运动，当两个输入电平压差越大，小车的转速越快，输入电平越小，小车转速越慢，输入电平的压差不一样，小车运动速度也就不一样，L293-IN2和L293-IN1驱动其中一个电机，一个引脚连接PWM输出端口，另一个连接普通端口，当固定普通端口输出电平为0时，只需要改变输出PWM值，即可改变转速，此时小车正转，当普通端口输出电平为1时，改变PWM输出值，也可以改变转速，此时小车反转，通过改变两引脚的输出值即可控制小车的姿态。</p><h1 id="三、-软件设计"><a href="#三、-软件设计" class="headerlink" title="三、 软件设计"></a>三、 软件设计</h1><h2 id="3-1-循迹模块设计"><a href="#3-1-循迹模块设计" class="headerlink" title="3.1 循迹模块设计"></a>3.1 循迹模块设计</h2><p>在 OpenMV 摄像头使用中，为了使循迹效果更好，采取了以下措施。</p><p>（1）提高识别速率。采用减小图像面积的方法，将摄像头捕获到的每一帧图像设置为 QQVGA 格式。</p><p>（2）滤除不稳定图帧。在摄像头进入工作状态的一段时间内，捕获的图像往往是不稳定的。通过调用内部集成函数skip_frames(n)使得摄像头跳过n帧图像，滤除不稳定的图像。</p><p>（3）颜色阈值相匹配。为了从图像中提取循迹的轨道，通过调用 binary_threshold 函数，将图像中颜色阈值为 threshold 的部分转换成白色，其他颜色阈值转换成黑色，且 threshold 的颜色阈值与本设计循迹轨道的颜色阈值相对应 [3]。</p><p>（4）校正 OpenMV 摄像头位置。使用 get_regression()函数进行线性回归处理，经处理后的图像可返回直线角度和直线偏移量等参数。其中，直线偏移量反映当前摄像头的位置。当该参数等于 0 时，表示摄像头处于中央位置 ；当该参数大于 0 时，摄像头偏向直线右侧；当该参数小于 0 时，摄像头偏向直线左侧，从而校正摄像头位置。</p><h2 id="3-2循迹路口判断设计"><a href="#3-2循迹路口判断设计" class="headerlink" title="3.2循迹路口判断设计"></a>3.2循迹路口判断设计</h2><p>​    本次循迹采用路径规划的方式来完成H型轨道的循迹，在循迹的过程中，小车MCU要完成对路口的判断，比如十字路口，T型路口等，本设计利用OpenMV采用颜色阈值与路口匹配的方式进行循迹。在小车循迹的过程当中，OpenMV会实时的捕获当前摄像头所拍摄的图像信息，并且在图像的中间矩形区域块，从左向右提取七个像素点，其中第四个像素点位于图像的正中央区域。其示意图如图3.1所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191344501.png" alt="img"></p><p>​    通过提取这七个像素点的颜色阈值，判断小车是否遇见路口以及路口的类型，包含 T十字形路口、左侧 T 形路口、右侧 T 形路口以及未遇见路口四种情况。将这 4种情况通过无符号 char 类型参数 Flag 表示，Flag 的数值范围为 0 ～ 3。</p><p>​    （1）如果1 ～ 7 像素点的颜色阈值相同且颜色阈值均为黑色，就说明摄像头中间区域块识别的全部都为黑线，则可判断小车遇到了十字形路口，设置Flag值为1，并且驱动小车按照规划路径进行循迹。其示意图下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191344220.png" alt="img"></p><p>​    （2）如果4 ～ 7 像素点的颜色阈值相同且颜色阈值均为黑色，而 1 ～ 4 像素点颜色阈值相同且颜色阈值为白色，就说明摄像头中间区域的右半边区域识别的为黑线，则可判断遇到了右侧T 形路口，设置Flag值为1，并且驱动小车进行右转弯。其示意图如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191344141.png" alt="img"></p><p>​     （3）如果 1 ～ 4 像素点颜色阈值相同且颜色阈值为黑色，而 4 ～ 7 像素点颜色阈值相同且颜色阈值为白色，就说明摄像头中间区域的左半边区域识别的为黑线，则可判断遇到了左侧T形路口，设置Flag值为2，并且驱动小车进行左转弯。其示意图如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191345470.png" alt="img"></p><p>​    （4）如果 1、2、3、5、6、7 像素点颜色阈值相同且为白色，但 4像素点颜色阈值单独为黑色不同，则未遇见路口，设置Flag值为3，驱动小车完成直线循迹。其示意图如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191940492.png" alt="image-20240319193250745"></p><p>​    以上 4 种情况对应的 Flag 数值分别为 0、1、2、3、4，最后将该数值以及直线偏移量由串口传入小车的 MCU 中进行处理。循迹路口判断流程图如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191345656.png" alt="img"></p><h2 id="3-3-PID直线循迹设计"><a href="#3-3-PID直线循迹设计" class="headerlink" title="3.3 PID直线循迹设计"></a>3.3 PID直线循迹设计</h2><p>​    PID算法：PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”，这三项构成PID 基本要素。每一项完成不同任务，对系统功能产生不同的影响。它的结构简单，参数易于调整，是控制系统中经常采用的控制算法。PID算法又分为位置式PID算法和增量式PID算法，我们设计采用位置式PID算法进行控制，位置式PID定义: </p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191415254.png" alt="img"></p><p>​     位置式PID算法是一种非递推式算法，控制量的值与执行机构的位置是一一对应的，所以能够很好的控制小车进行循迹，本设计的控制量为小车输出的PWM，执行机构为小车电机。小车输出的PWM值是由OpenMV传入小车的MCU的参数通过PID计算得到的，这个参数就是循迹轨道的距离偏移量，当小车处于路径中央位置时，偏移量为0，当小车向左偏移时，偏移量小于0且最小不小于90，当小车向右偏移时，偏移量大于0且最大不大于90。</p><p>​    传入小车的PWM参数计算主要由以下三个步骤得来的：</p><p>​    (1)消除OpenMV输出的负值偏移量。将整个偏移量加上200，此时小车在巡线中央位置所对应的偏移量为200，当小车向左偏移时，偏移量则小于200；当小车向右偏移时，偏移量则大于200。</p><p>​    (2)处理OpenMV传入的参数。将偏移量通过串口将数据发送给小车的MCU，在小车的MCU中我们再将传输的偏移量减去200进行数据还原。</p><p>​    (3)PID计算PWM值。在MCU中我们需要记录当前偏移量的值和上一次偏移量的值，以便于计算两次偏移量的偏差，随后计算出积分部分所需的积累偏差以及微分部分所需的差量。 </p><p>​    KP,KI,KD的初始值都为0，三个参数的值是通过不断的调试确定的；首先调节KP的值，不断的累加，使得值能够使得小车处于微震荡的状态；再调节KI的值,确定值的方法与值类似，通过累加，使得小车能够顺利的循迹并不出现抖动，在位置偏差较大时，也能迅速返回稳定的状态；再调节KD的值，使得最后的值能够在给小车一个外力使其偏移原来的轨道的情况下，能够使得小车迅速反馈并返回平稳的状态。最后根据PID的定义求出，将的数值在原有的基础PWM值上进行加减得到两轮的PWM值，在通过控制器分别控制两轮的速度，从而控制小车循迹。</p><h2 id="3-4-循迹方案设计"><a href="#3-4-循迹方案设计" class="headerlink" title="3.4 循迹方案设计"></a>3.4 循迹方案设计</h2><p>小车循迹H型赛道如图所示，依次到达ABC三点后返回起点。</p><p>对于ABC三点的循迹，采用分段路径规划的方法完成，其主要分为四个路径:</p><p>（1）路径一：从起点到A点。再驶向A点的过程中，首先会遇到一个T字型路口，此时我们让小车不做任何的操作继续进行直线循迹直到A点之后进行掉头；</p><p>（2）路径二：从A点到B点。从A点到B点过程中，会经过两个路口，第一个是T型路口，第二个是十字形路口，当小车在第一个T型路口时，让小车进行右转操作完成转向，再遇到十字型路口时，小车进行右转操作，到达B点会识别B点为十字形路口，此时让小车进行掉头；</p><p>（3）路径三：从B点到C点。再驶向C点的过程中，会遇到一个T字型路口，此时我们让小车不做任何的操作继续进行直线循迹直到C点之后进行掉头。</p><p>（4）路径四：从C点到起点。同样也会遇到两个路口，第一个是T型路口，第二个是十字形路口，当小车在第一个T型路口时，让小车进行左转操作完成转向，再遇到十字型路口时，小车同样进行左转操作，到达起点会识别起点为十字型路口，此时让小车停止，至此，小车完成整个H形轨迹循迹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pid_start</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">car_data = USART_RX_BUF[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(car_data&gt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     car_pid.error =car_data<span class="number">-100</span>;</span><br><span class="line">         kp_result = (u32)(car_pid.error*car_pid.kp);</span><br><span class="line"></span><br><span class="line">     car_pid.error_sum = car_pid.error_sum+car_pid.error;</span><br><span class="line">     ki_result = (u32)(car_pid.ki*car_pid.error_sum);</span><br><span class="line"></span><br><span class="line">     kd_result = (u32)(car_pid.kd*(car_pid.error-car_pid.error_latest));</span><br><span class="line">     car_pid.error_latest = car_pid.error;</span><br><span class="line">     out_put = kp_result+ki_result+kd_result;</span><br><span class="line"> speed_r =<span class="number">600</span> + out_put;</span><br><span class="line"> speed_l =<span class="number">650</span> - out_put;<span class="comment">//YOU</span></span><br><span class="line">     <span class="keyword">if</span>(out_put&gt;<span class="number">650</span>)&#123;speed_l = <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     car_pid.error =car_data;</span><br><span class="line">         kp_result = (u32)(car_pid.error*car_pid.kp);</span><br><span class="line"> </span><br><span class="line">     car_pid.error_sum = car_pid.error_sum+car_pid.error;</span><br><span class="line">     ki_result = (u32)(car_pid.ki*car_pid.error_sum);</span><br><span class="line"></span><br><span class="line">     kd_result = (u32)(car_pid.kd*(car_pid.error-car_pid.error_latest));</span><br><span class="line">     car_pid.error_latest = car_pid.error;</span><br><span class="line"></span><br><span class="line">     out_put = kp_result+ki_result+kd_result;</span><br><span class="line"> speed_r =<span class="number">600</span> - out_put;</span><br><span class="line"> speed_l =<span class="number">650</span> + out_put;</span><br><span class="line">    <span class="keyword">if</span>(out_put&gt;<span class="number">600</span>)&#123;speed_r = <span class="number">0</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//u2_printf(&quot;speed_l:%d speed_r:%d\r\n&quot;,speed_l,speed_r);</span></span><br><span class="line"><span class="built_in">Car_Turn_speed</span>(speed_l,speed_r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-5-避障模块设计"><a href="#3-5-避障模块设计" class="headerlink" title="3.5 避障模块设计"></a>3.5 避障模块设计</h2><p>​    我们采用HC-SR04模块实现避障，通过HC-SR04模块来获取小车与障碍物的距离，当两者的距离小于某个值的时候，就可以做出反应进行避障，HC-SR04模块主要有四个引脚，分别为VCC、GND、Trig(控制端)、Echo(接收端)，前两者通过给模块进行供电，后两者就用来计算与障碍物的距离，HC-SR04模块工作时序图：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191415708.png" alt="img"></p><p>​    实现方法：再模块通电的前提下首先给模块的Trig引脚拉高至少10us的高电平;模块会自动发送8个40kHz的方波，自动检测是否有信号返回;如果有信号返回，Echo引脚会给小车的MCU输入一个高电平，高电平持续的时间的就是超声波从发射到返回时间。</p><p>​    我们利用定时器的输入捕获功能计算高电平的时间，当引脚检测到上升沿时，进入中断，将计数值清零，同时设置中断触发方式为下降沿触发，当下降沿到来时，再次进入中断，此时定时器对应的计数值就等于高电平的计数值，再通过公式(测试距离&#x3D;((计数值&#x2F;定时器计数频率)*声速(340M&#x2F;S))&#x2F;2)计算距离，同时设置中断触发方式为上升沿触发，重复进行此过程，可以不断的求出小车与障碍物的距离。避障系统工作流程图：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191345870.png" alt="img"></p><h1 id="四、-实验测试分析"><a href="#四、-实验测试分析" class="headerlink" title="四、 实验测试分析"></a>四、 实验测试分析</h1><h2 id="4-1循迹测试"><a href="#4-1循迹测试" class="headerlink" title="4.1循迹测试"></a>4.1循迹测试</h2><p>​    首先对小车的循迹模块进行测试。理论上，如果小车的跑道是笔直的，小车可以一直顺着直线向前行驶。因此，我们不再对小车直线跑进行相关的调试，只调试小车的转弯性能。小车的转弯性能受多方面因素的影响，比如弯道的弯曲程度、小车转弯时电机的速度等等。根据实验室中已有小车的跑道，通过程序对小车的速度进行调整，让小车实现循迹功能。经过调试后发现，小车在跑道一中，转弯时的速度能达到6 cm&#x2F;s（全速时为 20 cm&#x2F;s，下同）；在跑道中，转弯的速度为 4 cm&#x2F;s。这是因为当传感器探测到黑线时，虽然电机驱动芯片切断了相对应的电机的电源，但是由于惯性，电机还会继续运转，不会马上刹车停下。因此，小车的转弯性能与其直线运动的速度之间有较大的关系。经过调试后发现，小车的转弯速度至少要比直线速度慢 1 cm&#x2F;s，要不然小车就会冲出跑道，导致循迹失败。</p><h2 id="4-2智能小车避障功能测试"><a href="#4-2智能小车避障功能测试" class="headerlink" title="4.2智能小车避障功能测试"></a>4.2智能小车避障功能测试</h2><p>​    小车的避障距离设置为30 cm，只有障碍物位于避障模块 30 cm 以内的距离时，小车才会对障碍物做出规避响应。我们选取小车对障碍物判断的准确性、对障碍物的响应距离、响应速度来对小车的避障功能进行评估。为测试小车对障碍物判断的准确性，选取4 个不同大小的物体来进行测试，障碍物的尺寸分 别 为 3 cm×5 cm、 6 cm×7 cm、 8 cm×12 cm、12 cm×16 cm。我们将障碍物放至距离小车 30 cm 处，测试小车是否能正确检测到前方障碍物。经过测试，当 3 cm×5 cm 的障碍物和 6 cm×7 cm 的障碍物放置小车前方时，小车无法正常识别，识别准确率仅为 40%；但小车对尺寸为 8 cm×12 cm 和 12 cm×16 cm 的障碍物的识别准确率可达 100%。分析发现，出现这种情况的原因是 HC-SR04 的硬件特性。HC-SR04 的测量角度为 15°， 在 30 cm 处仅可测量高度大于 8 cm 的物体，因此在检测 3 cm×5 cm和 6 cm×7 cm 的障碍物时，可能会出现误检的情况。为测试小车的响应距离和响应速度，将小车对障碍物的感应距离设置为 30 cm，选取尺寸为8 cm×12 cm 和 12 cm×16 cm 的障碍物，分别放置障碍物。再次经过测试，小车对面积比较大的障碍物响应时间更短。针对同一个障碍物，距离越短，小车的响应时间和距离越短。这是由于小车在运行中无障碍物的情况下会有加速过程；在检测到障碍物之后，小车的步进电机会有刹车动作。从检测到障碍物到小车完全静止，小车行进的距离即为响应距离。在面对距离较近的障碍物时，小车速度较低，响应距离相对较短。在面对距离较远的障碍物时，小车的速度较高，对应的刹车距离也变长。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FSMC移位</title>
      <link href="/2024/03/18/FSMC%E7%A7%BB%E4%BD%8D/"/>
      <url>/2024/03/18/FSMC%E7%A7%BB%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>本质上是字节寻址和字寻址的问题</p><p>以数组举例</p><p>u8 string[6]，我们可以对这数组的10个单元进行寻址，每个单元的地址都是差1个单位</p><p>假设string[0]地址为0x00，则</p><p>string[1]         0x01   0x0000 0001</p><p>string[2]         0x02   0x0000 0010</p><p>string[3]         0x03   0x0000 0011</p><p>string[4]         0x04   0x0000 0100</p><p>string[5]         0x05   0x0000 0101</p><p>这正好对应到我们FSMC的8位寻址</p><p>u16 string[6] </p><p>string[0]         0x00   0x0000 0000</p><p>string[1]         0x02   0x0000 0010</p><p>string[2]         0x04   0x0000 0100</p><p>string[3]         0x06   0x0000 0110</p><p>string[4]         0x08   0x0000 1000</p><p>string[5]         0x0A   0x0000 1010</p><p>这里为什么地址都变为偶数了呢，因为规定数组每个数据都占2个字节（u16），所以每个数据的地址都相差两个单位（两个字节），所以地址都是偶数。</p><p>所以当我们的外部存储器为8位时，是按字节寻址，FSMC配置8位寻址，也是按字节寻址，则一个地址则对应一个位，就不需要移位</p><p><strong>字节寻址</strong>：一个单元代表一个字节  地址0x01和地址0x02一共占据2个字节的数据</p><p>上面的例子就是按字节寻址</p><p><strong>按字寻址</strong>：假如一个字代表两个字节，则一个单元代表2个字节   地址0x01和地址0x02一共占据4个字节的数据</p><p>当我们的外部存储器为16位时，按<strong>字节寻址</strong>，<strong>存储器的每一个地址都表示一个16位的数据，</strong>而对于STM32FSMC来说，配置16位模式，则每写一个数据，他们之间的地址就相差两个字节，如果不移位，0x00 0x02地址写入数据，对于按字寻址的存储器来说，就是写入了0x00（16位数据），0x02（16位数据），可以看到，中间的0x01地址被跳过（注意这里是字寻址，一个单位代表一个字，16位），则会造成数据的混乱，所以需要将数据左移一位，相当于除以2，偶地址变成奇地址，对应16位按字节寻址的存储器，就不会有数据跳过了。</p><p>0000 0000       左移  0x0000 0000  </p><p>0000 0010       左移  0x0000 0001</p><p>0000 0100       左移  0x0000 0010</p><p>补充：对32位的处理器，一个字代表4个字节</p><p>​      对64位的处理器，一个字代表8个字节</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈unsigned和signed的区别</title>
      <link href="/2024/03/18/%E6%B5%85%E8%B0%88unsigned%E5%92%8Csigned%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/03/18/%E6%B5%85%E8%B0%88unsigned%E5%92%8Csigned%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>​在我们写c语言的程序中，总是能看见unsigned的关键字，unsigned的作用是声明无符号的整形类型，与signed对应。这个关键字是挺常见的。</p><ul><li><p>unsigned：用来声明无符号的整形变量</p></li><li><p>signed：用来声明有符号的整形变量</p></li></ul><p>​         我们以（signed int a）与（unsigned int a）进行举例，再谈其区别的时，我们先来说说整形数据的存储，计算机存储数据都是以二进制数据进行存储的，其中负数的存储方式为补码进行存储的，而正数的补码与原码是相同的。</p><p>​       对于有符号的整形变量来说（signed）最高位0和1表示这个数值的符号，0代表正数，1代表负数，其余位表示数据。</p><p>​        对于无符号的整形变量来说（unsigned）所有位都表示数据，我们可以很直观的看到两者表示数的范围是不同的，如果系统中的a是32位的int，那么signed int 表示的范围为-2^31<del>2^31-1（最高位表示符号，不表示数据），而unsigned表示的范围为0</del>2^32。</p><p>​       所以在我们定义一个整形数据发现数据超过了2的15次方时，我们可以用unsigned的关键字来定义这个数，这样数据的范围扩大一倍，如果想打印出这个数据，我们一般用%u进行打印而不用%d，这里的%u是无符号的10进制正数，%d是有符号的10进制整数，使用%d时会把无符号的数据自动转换为有符号的数据，那么得到的数跟没有定义unsigned的数区别就不大了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言指针浅析</title>
      <link href="/2024/03/18/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E6%B5%85%E6%9E%90/"/>
      <url>/2024/03/18/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    指针是C语言中的一个重要概念及其特点也是掌握 C语言比较困难的部分。 <strong>指针也就是内存地址</strong> ，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的 存储空间 长度也不同。 有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。 </p><h1 id="一-指针概念"><a href="#一-指针概念" class="headerlink" title="一.指针概念"></a>一.指针概念</h1><h2 id="1-1-指针的类型"><a href="#1-1-指针的类型" class="headerlink" title="1.1 指针的类型"></a>1.1 指针的类型</h2><p><strong>去掉指针本身剩下的就是指针的类型</strong></p><ul><li>int<em>ptr;&#x2F;&#x2F;指针的类型是int</em></li><li>char<em>ptr;&#x2F;&#x2F;指针的类型是char</em></li><li>int<strong>ptr;&#x2F;&#x2F;指针的类型是int</strong></li><li>int(<em>ptr)[3];&#x2F;&#x2F;指针的类型是int(</em>)[3]</li><li>int*(<em>ptr)[4];&#x2F;&#x2F;指针的类型是int</em>(*)[4]</li></ul><h2 id="1-2-指针所指向的类型"><a href="#1-2-指针所指向的类型" class="headerlink" title="1.2 指针所指向的类型"></a>1.2 指针所指向的类型</h2><p><strong>去掉指针本身和指针前面的*剩下的就是指针所指向的类</strong>                             </p><ul><li>int*ptr; &#x2F;&#x2F;指针所指向的类型是int</li><li>char*ptr; &#x2F;&#x2F;指针所指向的的类型是char</li><li>int*<em>ptr; &#x2F;&#x2F;指针所指向的的类型是int</em></li><li>int(*ptr)[3]; &#x2F;&#x2F;指针所指向的的类型是int()[3]</li><li>int*(<em>ptr)[4]; &#x2F;&#x2F;指针所指向的的类型是int</em>()[4]</li></ul><h2 id="1-3-指针的值"><a href="#1-3-指针的值" class="headerlink" title="1.3 指针的值"></a>1.3 指针的值</h2><p>​    指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。64位也是如此，在64位程序中，所有类型的指针的值都是64位整数。指针所存储的值是地址。</p><h2 id="1-4-和"><a href="#1-4-和" class="headerlink" title="1.4 &amp;和*"></a>1.4 &amp;和*</h2><ul><li><strong>&amp;：</strong>&amp;在指针运算中为取地址符号</li><li>*** :**  *在指针运算中为获取地址所指向内存单元的值的符号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;                      <span class="comment">//定义指针</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>;                     <span class="comment">//定义变量</span></span><br><span class="line">p=&amp;a;                        <span class="comment">//赋值指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p:%d,a:%d&quot;</span>,*p,a);  </span><br><span class="line">运行结果</span><br><span class="line">p:<span class="number">1</span>a:<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>&amp;*p和*&amp;p的区别：</strong></p><p>因为*和&amp;具有相同的优先级，且是右结合性（从右向左），故分析可得：</p><p>​    <strong>1）&amp;*p：</strong>相当于&amp;(<em>p)，首先进行一次</em>p运算再取地址。若p是一个非指针变量，<em>p是非法的；若p是一个指针变量，&amp;(<em>p)&#x3D;p；<br>​     <strong>2）*&amp;p：</strong>相当于*(&amp;p)，先取地址再做*运算。若p是一个非指针变量，</em>(&amp;p)&#x3D;p；若p是一个指针变量，</em>(&amp;p)&#x3D;p。</p><h2 id="1-5-指针的运算"><a href="#1-5-指针的运算" class="headerlink" title="1.5 指针的运算"></a>1.5 指针的运算</h2><p>​    对于指向数组的指针变量，可以加上或减去一个整数n，这意味着把指针从当前指向的位置（指向的某个数组元素）向后或向前移动n个位置。</p><p>这里应当注意：<br>     (1)<strong>数组指针变量向前向后移动一个位置和地址加1或减1在概念上是不同的</strong>。因为数组的元素可以由不同的数据类型，所占用的字节长度也是不同的。如指针变量加1，即表示指针变量指向下一个元素的首地址，而不是在原地址的基础上加1；<br>     (2)指针变量的加减运算只能对数组指针变量进行，对只想其他数据类型的指针变量做加减运算是毫无意义的。<br>     (3)两个指针变量之间的运算：只有指向同一数组的两个指针变量才能进行运算，否则运算是毫无意义的。<br>     (4)两指针变量相减：两指针变量相减所得之差，是两个指针所指向的数据元素之间相差的元素个数，乘以该数组每个数据元素的长度（字节数）；<br>     (5)两指针变量相加：两指针变量不能进行加法运算，毫无实际意义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*p; <span class="comment">//p所指向的类型为int类型</span></span><br><span class="line"></span><br><span class="line">p++; <span class="comment">//p+1地址数增加四个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1; <span class="comment">//p1所指向的类型为char类型</span></span><br><span class="line"></span><br><span class="line">p1++; <span class="comment">//p1+1地址数增加1个字节</span></span><br></pre></td></tr></table></figure><h1 id="二-指针与一维数组"><a href="#二-指针与一维数组" class="headerlink" title="二.指针与一维数组"></a>二.指针与一维数组</h1><h2 id="2-1-一维数组"><a href="#2-1-一维数组" class="headerlink" title="2.1 一维数组"></a>2.1 一维数组</h2><h3 id="2-1-1-一维数组的初始化"><a href="#2-1-1-一维数组的初始化" class="headerlink" title="2.1.1 一维数组的初始化"></a>2.1.1 一维数组的初始化</h3><p>(1)在定义数组时对所有数组元素赋初值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> data[<span class="number">5</span>]=&#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>(2)对数组部分元素赋初值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">5</span>]=&#123;<span class="number">100</span>,<span class="number">99</span>&#125;;</span><br></pre></td></tr></table></figure><p>将100、99赋给data[0]、data[1]，其余数组元素自动赋值0。</p><p>(3)对全部数组元素赋处置，省略数组长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[]=&#123;<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>将初值依次赋值给数组的各个元素，数组长度由<strong>初值个数决定</strong>。</p><h1 id="三-指针与二维数组"><a href="#三-指针与二维数组" class="headerlink" title="三.指针与二维数组"></a>三.指针与二维数组</h1><h3 id="3-1-1-二维数组的初始化"><a href="#3-1-1-二维数组的初始化" class="headerlink" title="3.1.1 二维数组的初始化"></a>3.1.1 二维数组的初始化</h3><p>(1)按行给二维数组初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> socre[<span class="number">4</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">96</span>,<span class="number">95</span>,<span class="number">94</span>&#125;,&#123;<span class="number">93</span>,<span class="number">92</span>,<span class="number">91</span>&#125;,&#123;<span class="number">90</span>,<span class="number">89</span>,<span class="number">88</span>&#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>99</th><th>98</th><th>97</th></tr></thead><tbody><tr><td>96</td><td>95</td><td>94</td></tr><tr><td>93</td><td>92</td><td>91</td></tr><tr><td>90</td><td>89</td><td>88</td></tr></tbody></table><p>(2)按排列数序初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> score=[<span class="number">4</span>][<span class="number">3</span>]&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">96</span>,<span class="number">95</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">92</span>,<span class="number">91</span>,<span class="number">90</span>,<span class="number">89</span>,<span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure><p>(3)对部分元素赋初值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> socre[<span class="number">4</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">99</span>,<span class="number">98</span>&#125;,&#123;<span class="number">96</span>,<span class="number">95</span>,&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score[<span class="number">4</span>][<span class="number">3</span>]=&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">96</span>,<span class="number">95</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">92</span>&#125;</span><br></pre></td></tr></table></figure><p>对二维数组进行赋值，为赋初值的数组元素，系统自动赋值为0</p><p>(4)初始化时省略第一维长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> socre[][<span class="number">3</span>]=&#123;&#123;<span class="number">99</span>,<span class="number">98</span>&#125;,&#123;<span class="number">96</span>,<span class="number">95</span>,&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score[][<span class="number">3</span>]=&#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">96</span>,<span class="number">95</span>,<span class="number">94</span>,<span class="number">93</span>,<span class="number">92</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-二维数组与指针"><a href="#3-2-二维数组与指针" class="headerlink" title="3.2 二维数组与指针"></a>3.2 二维数组与指针</h2><h3 id="3-2-1-二维数组与指针的关系"><a href="#3-2-1-二维数组与指针的关系" class="headerlink" title="3.2.1 二维数组与指针的关系"></a>3.2.1 二维数组与指针的关系</h3><p>​    在c语言中，二维数组可以看作是一维数组的嵌套而构成的，一个二维数组可以按行分解成多个一维数组。例如，有如下定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>​    二维数组a可分解为三个一维数组，其<strong>数组名</strong>分别为<strong>a[0]</strong>,<strong>a[1]</strong>,**a[2]**。每个一维数组有四个元素。</p><p>​    c语言规定数组名代表数组的首地址，因此a[i]是第i行第0列的数组元素(a[i][0])的地址，即a[i]与&amp;a[i][0]等价,即a[i]+j就是第i行第j列的数组元素a[i][j]的地址,即a[i]+j与&amp;a[i][j]等价。所以对于二维数组a有以下关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i]+j等价于&amp;a[i][j]</span><br><span class="line"></span><br><span class="line">*(a[i]+j)等价于a[i][j]</span><br></pre></td></tr></table></figure><p>​    根据一维数组与指针的关系可知:a[i]等价于*(a+i)，进而可推出二维数组与指针的关系:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)*(a+i)+j等价于&amp;a[i][j]</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)*(*(a+i)+j)等价于a[i][j]</span><br></pre></td></tr></table></figure><h2 id="3-3-数组指针"><a href="#3-3-数组指针" class="headerlink" title="3.3 数组指针"></a>3.3 数组指针</h2><p>**数组指针:**指向数组的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*p)[i];</span><br><span class="line"></span><br><span class="line">p++；</span><br></pre></td></tr></table></figure><p>首先要明确优先级顺序：()&gt;[]&gt;*</p><p>​    (* p)[n]:根据优先级，先看括号内的，p是一个指针，指向一个一维数组，数组的长度是n，这是指向数组的指针，叫做数组指针。</p><p>​    指针的类型为int(*)[i],指针所指向的类型为int()[i],在运行p+1时，p所指向的地址在原有的地址上增加sizeof(int)*i。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191427701.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="3-4-指针数组"><a href="#3-4-指针数组" class="headerlink" title="3.4 指针数组"></a>3.4 指针数组</h2><p><strong>指针数组:装着指针的数组。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p[<span class="number">4</span>];</span><br><span class="line">p++;</span><br></pre></td></tr></table></figure><p>​     <em>p[n]:根据优先级，先看[]，则p是一个数组，再结合</em>，这个数组的元素是指针类型，共n个元素，是装着指针的数组，叫做指针数组。</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191428150.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>​    指针数组++是指将指向指针数组第一个元素的指针向后移动一个元素的位置。具体来说，如果有一个指针数组<code>p</code>，其中包含n个指针，每个指针指向不同的内存地址，那么<code>p++</code>将把指针向后移动一个元素的位置，即指向<code>p[1]</code>的指针。如果再执行<code>p++</code>，则指针将指向<code>p[2]</code>，以此类推。</p><h2 id="3-5-指针数组和数组指针"><a href="#3-5-指针数组和数组指针" class="headerlink" title="3.5 指针数组和数组指针"></a>3.5 指针数组和数组指针</h2><p>​    指针数组和数组指针是两个不同的概念。</p><p>​    指针数组是一个数组，其中的每个元素都是一个指针，每个指针指向不同的内存地址。例如，<code>int *ptrArr[10]</code>定义了一个包含10个指向int类型的指针的数组，每个指针都可以指向不同的int类型变量。</p><p>​    数组指针是一个指针，它指向一个数组的首地址。例如，<code>int (*arrPtr)[10]</code>定义了一个指向包含10个int类型元素的数组的指针。在这种情况下，<code>arrPtr</code>指向的是整个数组，而不是数组中的一个元素。</p><p>​    因此，指针数组和数组指针的本质区别在于它们的类型不同，<strong>一个是数组，一个是指针</strong>。指针数组中的每个元素都是一个指针，而数组指针指向的是一个数组。在使用时需要根据具体情况选择合适的类型。</p><p><strong>问题：</strong>指针数组名到底是数组名还是指针名？</p><p>​    指针数组名既可以被视为指针名，也可以被视为数组名，具体取决于它的上下文环境。</p><p>​    在指针数组作为函数参数传递时，指针数组名被视为指针名。因为在函数调用时，指针数组会被转换为指向其首元素的指针，并传递给函数。因此，指针数组名被视为指向数组首元素的指针名。</p><p>例如，下面的函数原型中，<code>ptrArr</code>被视为指向数组首元素的指针名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *ptrArr[], <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>​    在指针数组被定义时，指针数组名被视为数组名。因为指针数组本质上是一个数组，指针数组名表示整个数组。在定义指针数组时，需要指定数组的长度，这个长度就是数组的元素个数。</p><p>例如，下面的定义中，<code>ptrArr</code>被视为数组名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrArr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>​    因此，指针数组名既可以被视为指针名，也可以被视为数组名，具体取决于它的上下文环境。</p><h1 id="四-指针与字符串"><a href="#四-指针与字符串" class="headerlink" title="四.指针与字符串"></a>四.指针与字符串</h1><h2 id="4-1-字符数组"><a href="#4-1-字符数组" class="headerlink" title="4.1 字符数组"></a>4.1 字符数组</h2><p>对字符数组的初始化有以下几种情形</p><p>(1)和其他数组一样，对字符数组逐个初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意:c语言规定以字符’\0’作为字符串的结束标志。如果没有’\0’，只能说数组str中存储了一串字符，但不能说str存储了字符串。</p><p>(2)用字符串直接初始化字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>​    编译器将双括号括起来的字符依次赋值给字符数组的各个元素，并自动在末尾补上字符结束标志字符’\0’,一起存在数组str中，所以数组的个数要比字符串中字符的个数要多一个。在输出字符串时，末尾’\0’不输出，只用于判断字符串是否结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>​    按这种方式定义和初始化字符串数组，不必指定数组的大小，编译系统会根据字符串中字符的个数确定数组的大小。由于字符串常量”hello”的末尾字符时’\0’,因此字符数组的长度为字符串的额中世纪的个数加1，即：字符数组str的长度为6。</p><h2 id="4-2-字符指针"><a href="#4-2-字符指针" class="headerlink" title="4.2 字符指针"></a>4.2 字符指针</h2><p>​    字符指针时指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一的首地址。因此，只要把字符串的首地址赋值给字符指针，即可让字符指针指向字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p;</span><br><span class="line">p=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p;</span><br><span class="line">p=str; </span><br></pre></td></tr></table></figure><h1 id="五-指针函数与函数指针"><a href="#五-指针函数与函数指针" class="headerlink" title="五.指针函数与函数指针"></a>五.指针函数与函数指针</h1><h2 id="5-1-指针函数"><a href="#5-1-指针函数" class="headerlink" title="5.1 指针函数"></a>5.1 指针函数</h2><p><strong>1.指针函数的概念</strong></p><p>​    指针函数是一种特殊类型的函数，其特点是其返回值的类型为某一类型的指针。也就是说，这种函数的返回值是一个地址，这个地址指向函数内部某种特定类型的变量或者数据结构。</p><p><strong>2.指针函数的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针类型 * （函数名称）(函数的参数列表类型) </span><br></pre></td></tr></table></figure><p><strong>3.指针函数的使用</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">find_max</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a[<span class="number">0</span>]; <span class="comment">// 定义一个指向数组首元素的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p &lt; a[i]) &#123;</span><br><span class="line">            p = &amp;a[i]; <span class="comment">// 如果当前元素大于指针所指向的元素，则更新指针的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回指向最大元素的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> *max_ptr = <span class="built_in">find_max</span>(arr, n); <span class="comment">// 调用find_max函数，将最大元素的地址赋给max_ptr指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value is %d&quot;</span>, *max_ptr); <span class="comment">// 输出最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5-2-函数指针"><a href="#5-2-函数指针" class="headerlink" title="5.2 函数指针"></a>5.2 函数指针</h2><p><strong>1.函数指针的概念</strong></p><p>​    函数指针是一种特殊类型的指针，它指向函数而非变量。这种指针在内存中储存的是函数的入口地址，我们可以通过这个地址来调用相应的函数。</p><p><strong>2.函数指针的定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数的返回值类型（*指针名）（函数的参数列表类型）</span><br></pre></td></tr></table></figure><p><strong>3.函数指针的使用</strong><br>     下面是一个函数指针的使用，首先定义一个max函数，然后在主函数内声明函数指针，再将max函数地址传递给函数指针，最后调用函数指针即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*func_ptr)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 声明一个函数指针变量</span></span><br><span class="line">    func_ptr = max; <span class="comment">// 将函数max的地址赋给函数指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value is %d&quot;</span>, <span class="built_in">func_ptr</span>(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 输出最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake浅析</title>
      <link href="/2024/03/18/CMake/"/>
      <url>/2024/03/18/CMake/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer"><h1 id="一-什么是CMake"><a href="#一-什么是CMake" class="headerlink" title="一.什么是CMake"></a>一.什么是CMake</h1><p>CMake是一个跨平台的开源构建工具，用于管理和构建软件项目。它采用一种声明式的语法来描述项目的构建过程，并生成适应不同平台和编译器的构建系统文件，如Makefile或Visual Studio项目文件。</p><p>CMake的设计目标是提供一个独立于特定编译器和操作系统的构建系统。它允许开发者使用统一的方式来描述项目的构建需求，并生成适应不同环境的构建系统文件。这使得开发者可以在不同平台和编译器上轻松地构建和管理项目。</p><p>使用CMake，开发者需要编写一个名为CMakeLists.txt的配置文件，其中包含了项目的源文件、库依赖、编译选项、链接选项等信息。CMake会根据这个配置文件生成相应的构建系统文件，然后使用生成的构建系统文件来构建项目。</p><p>CMake编译流程图如下图所示：</p><p><img src="https://gitee.com/ry2001/img/raw/master/202403191650253.jpeg"></p><p>CMake具有以下特点和优势：</p><ul><li><p><strong>跨平台性</strong>：CMake可以生成适应不同操作系统和编译器的构建系统文件，使得项目能够在多个平台上进行构建和运行。</p></li><li><p><strong>可扩展性</strong>：CMake支持自定义模块和函数，开发者可以编写CMake脚本来实现更复杂的构建逻辑，满足特定项目的需求。</p></li><li><p><strong>高效性</strong>：CMake使用高效的生成系统，能够并行编译多个目标，提高构建速度。</p></li><li><p><strong>广泛的应用</strong>：CMake被广泛应用于各种类型的项目，包括开源软件、商业软件、嵌入式系统等。</p></li><li><p><strong>社区支持</strong>：CMake拥有庞大的社区支持和活跃的开发者社区，有大量的文档、教程和示例可供参考。</p></li></ul><h1 id="二-CMake安装"><a href="#二-CMake安装" class="headerlink" title="二.CMake安装"></a>二.CMake安装</h1><ol><li><p>绝大多数的linux系统已经安装了CMake</p></li><li><p>Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p></li></ol><h1 id="三-CMake一个HelloWord-的语法介绍"><a href="#三-CMake一个HelloWord-的语法介绍" class="headerlink" title="三.CMake一个HelloWord-的语法介绍"></a>三.CMake一个HelloWord-的语法介绍</h1><p>一个CMakeLists.txt文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">PROJECT</span> (HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> <span class="variable">$&#123;HELLO_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span><span class="variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-1-PROJECT关键字"><a href="#3-1-PROJECT关键字" class="headerlink" title="3.1 PROJECT关键字"></a>3.1 PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p><code>PROJECT (HELLO) </code>  指定了工程的名字，并且支持所有语言—建议</p><p><code>PROJECT (HELLO CXX) </code>  指定了工程的名字，并且支持语言是C++</p><p><code>PROJECT (HELLO C CXX)  </code>  指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</projectname></p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</projectname></p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p><strong>问题：</strong>如果改了工程名，这两个变量名也会改变</p><p><strong>解决：</strong>又定义两个预定义变量：<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DI</code>R，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="3-2-SET关键字"><a href="#3-2-SET关键字" class="headerlink" title="3.2 SET关键字"></a>3.2 SET关键字</h2><p>在CMake中，<code>set</code>是一个重要的关键字，用于设置变量的值。它的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt; [CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]])</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;variable&gt;</code>是要设置的变量名，<code>&lt;value&gt;</code>是要赋给变量的值。<code>&lt;variable&gt;</code>可以是已存在的变量，也可以是新创建的变量。</p><p><code>set</code>关键字还支持一些可选参数：</p><ul><li><p><code>CACHE</code>：指定变量为缓存变量，可以在构建过程中通过命令行或图形界面进行设置。缓存变量的值会被保存在CMake缓存中，下次运行CMake时会使用缓存中的值。</p></li><li><p><code>type</code>：指定缓存变量的类型，可以是<code>STRING</code>、<code>PATH</code>、<code>FILE</code>、<code>BOOL</code>等。</p></li><li><p><code>docstring</code>：对变量的描述，会在命令行或图形界面中显示。</p></li><li><p><code>FORCE</code>：强制设置变量的值，即使变量已经存在。</p></li></ul><p>下面是一些示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置普通变量</span></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置缓存变量</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug CACHE <span class="keyword">STRING</span> <span class="string">&quot;Build type&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置路径变量</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_PATH /path/to/library)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制设置变量的值</span></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp FORCE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个变量的值</span></span><br><span class="line"><span class="keyword">set</span>(my_var <span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过使用<code>set</code>关键字，可以在CMake中创建和设置变量，并根据需要指定变量的类型和属性。这些变量可以用于控制项目的构建过程，例如指定源文件、库路径、编译选项等。</p><h2 id="3-3-MESSAGE关键字"><a href="#3-3-MESSAGE关键字" class="headerlink" title="3.3 MESSAGE关键字"></a>3.3 MESSAGE关键字</h2><p>在CMake中，<code>MESSAGE</code>关键字用于输出消息到CMake的生成过程中。它可以用于调试、显示变量的值、输出提示信息等。</p><p><code>MESSAGE</code>关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MESSAGE</span>([&lt;mode&gt;] <span class="string">&quot;message&quot;</span> ...)</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;mode&gt;</code>是可选参数，用于指定消息的类型。常用的消息类型包括：</p><ul><li><code>STATUS</code>：输出一条状态消息，通常用于显示进度信息或提示信息。</li><li><code>WARNING</code>：输出一条警告消息，表示可能存在问题，但不会导致构建失败。</li><li><code>AUTHOR_WARNING</code>：输出一条作者警告消息，表示可能存在重要问题，可能导致构建失败。</li><li><code>SEND_ERROR</code>：输出一条错误消息，并停止构建过程。</li><li><code>FATAL_ERROR</code>：输出一条致命错误消息，并停止构建过程。</li></ul><p>下面是一些示例用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MESSAGE</span>(<span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is a status message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(WARNING <span class="string">&quot;This is a warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(AUTHOR_WARNING <span class="string">&quot;This is an author warning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(SEND_ERROR <span class="string">&quot;This is an error message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;This is a fatal error message&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这些示例中，<code>MESSAGE</code>关键字被用于输出不同类型的消息。你可以根据需要选择适当的消息类型来输出相应的信息。</p><p>通过使用<code>MESSAGE</code>关键字，你可以在CMake生成过程中输出消息，帮助你了解构建的进展、调试问题以及向用户提供必要的提示和警告信息。</p><h2 id="3-4-ADD-EXECUTABLE关键字"><a href="#3-4-ADD-EXECUTABLE关键字" class="headerlink" title="3.4 ADD_EXECUTABLE关键字"></a>3.4 ADD_EXECUTABLE关键字</h2><p>在CMake中，<code>ADD_EXECUTABLE</code>关键字用于定义一个可执行文件的构建规则。它将源代码文件编译为可执行文件，并指定可执行文件的名称和依赖项。</p><p><code>ADD_EXECUTABLE</code>关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(&lt;<span class="keyword">target</span>&gt; [source1] [source2] ...)</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;target&gt;</code>是指定的目标名称，用于指定生成的可执行文件的名称。<code>source1</code>、<code>source2</code>等是源代码文件的路径，用于指定构建可执行文件所需的源代码文件。</p><p>以下是一个示例用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义可执行文件的构建规则</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(my_app main.cpp utils.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件的依赖项</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(my_app my_library)</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>ADD_EXECUTABLE</code>关键字定义了一个名为<code>my_app</code>的目标，它由<code>main.cpp</code>和<code>utils.cpp</code>两个源代码文件构建而成。你可以根据实际情况指定更多的源代码文件。</p><p>此外，你可以使用<code>TARGET_LINK_LIBRARIES</code>关键字将可执行文件与其他库进行链接。在示例中，<code>TARGET_LINK_LIBRARIES</code>用于将<code>my_app</code>与名为<code>my_library</code>的库进行链接。</p><p>通过使用<code>ADD_EXECUTABLE</code>关键字，你可以定义可执行文件的构建规则，并指定它的源代码文件和依赖项。这样，在构建过程中，CMake将根据定义生成相应的可执行文件。</p><h2 id="3-5-include-directories关键字"><a href="#3-5-include-directories关键字" class="headerlink" title="3.5 include_directories关键字"></a>3.5 include_directories关键字</h2><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是include_directories:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(headpath)</span><br></pre></td></tr></table></figure><p>举例说明，有源文件若干，其目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure><p>CMakeLists.txt文件内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(HOME /home/robin/Linux/calc)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin/)</span><br><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;PROJECT_SOURCE_DIR&#125;/include)</span></span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p><h2 id="3-6-aux-source-directory"><a href="#3-6-aux-source-directory" class="headerlink" title="3.6 aux_source_directory"></a>3.6 aux_source_directory</h2><p><code>aux_source_directory</code>是CMake中的一个命令，用于将指定目录中的源文件自动添加到当前CMakeLists.txt文件的源文件列表中。</p><p>该命令的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;dir&gt;</code>是要搜索的目录路径，<code>&lt;variable&gt;</code>是存储搜索到的源文件列表的变量名。</p><p>使用<code>aux_source_directory</code>命令后，CMake会自动扫描指定目录中的源文件，并将其添加到当前CMakeLists.txt文件的源文件列表中。这样，在构建过程中，这些源文件就会被编译和链接到最终的可执行文件或库中。</p><p>以下是一个示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(src DIR_SRCS)</span><br><span class="line"><span class="keyword">add_executable</span>(MyApp <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>aux_source_directory</code>命令将目录<code>src</code>中的所有源文件自动添加到变量<code>DIR_SRCS</code>中。然后，通过<code>add_executable</code>命令将<code>DIR_SRCS</code>中的源文件编译为可执行文件<code>MyApp</code>。</p><p>需要注意的是，<code>aux_source_directory</code>命令会自动将指定目录中的所有源文件添加到列表中，包括子目录中的源文件。如果希望只添加指定目录下的源文件，可以使用<code>file(GLOB ...)</code>命令结合正则表达式来筛选文件。</p><p>总之，<code>aux_source_directory</code>命令是CMake中用于自动添加指定目录中的源文件到源文件列表的命令。它可以简化项目的配置，使得源文件的管理更加方便。</p><h1 id="四-语法的基本原则"><a href="#四-语法的基本原则" class="headerlink" title="四.语法的基本原则"></a>四.语法的基本原则</h1><ul><li><p>变量使用<code>$&#123;&#125;</code>方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="4-1-语法注意事项"><a href="#4-1-语法注意事项" class="headerlink" title="4.1 语法注意事项"></a>4.1 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="五-内部构建和外部构建"><a href="#五-内部构建和外部构建" class="headerlink" title="五.内部构建和外部构建"></a>五.内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="5-1-外部构建方式举例"><a href="#5-1-外部构建方式举例" class="headerlink" title="5.1 外部构建方式举例"></a>5.1 外部构建方式举例</h2><p>当使用CMake进行外部构建时，你需要创建一个独立的构建目录，并在该目录中运行CMake来配置构建过程。这样做的好处是将构建过程的产物（如编译生成的文件、中间文件等）与源代码分开，保持项目目录的整洁。</p><p>下面是外部构建的详细步骤：</p><ol><li><p>创建一个独立的构建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure></li><li><p>在构建目录中运行CMake命令来配置构建过程。你需要指定项目源代码的路径，可以是相对路径或绝对路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake /path/to/source 或者cmake .. //返回项目源代码路径</span><br></pre></td></tr></table></figure><p>在配置过程中，CMake会读取项目的CMakeLists.txt文件，并生成构建系统所需的Makefile或其他构建脚本。</p></li><li><p>进行构建。使用适合你的构建系统的命令，如<code>make</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>这将根据生成的构建系统文件执行实际的构建过程。构建结果（如可执行文件、库文件等）将生成在构建目录中。</p></li></ol><p>当使用CMake进行内部构建时，你直接在项目源代码目录中运行CMake命令，而不需要创建额外的构建目录。这种方式更简单，但可能会导致项目目录的混乱。</p><p>下面是内部构建的详细步骤：</p><ol><li><p>进入项目源代码目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/source</span><br></pre></td></tr></table></figure></li><li><p>在项目源代码目录中运行CMake命令来配置构建过程。使用<code>.</code>表示当前目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure><p>CMake将读取当前目录下的CMakeLists.txt文件，并生成构建系统所需的Makefile或其他构建脚本。</p></li><li><p>进行构建。使用适合你的构建系统的命令，如<code>make</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>这将根据生成的构建系统文件执行实际的构建过程。构建结果将生成在项目源代码目录中。</p></li></ol><blockquote><p>注意外部构建的两个变量</p><ol><li>HELLO_SOURCE_DIR  还是工程路径</li><li>HELLO_BINARY_DIR   编译路径 也就是 &#x2F;root&#x2F;cmake&#x2F;bulid</li></ol></blockquote><h1 id="六-编译多个源文件"><a href="#六-编译多个源文件" class="headerlink" title="六.编译多个源文件"></a>六.编译多个源文件</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT&#x2F;README 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;</li></ul><h2 id="6-1-将目标文件放入构建目录的-bin-子目录"><a href="#6-1-将目标文件放入构建目录的-bin-子目录" class="headerlink" title="6.1 将目标文件放入构建目录的 bin 子目录"></a>6.1 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="6-1-1-ADD-SUBDIRECTORY-指令"><a href="#6-1-1-ADD-SUBDIRECTORY-指令" class="headerlink" title="6.1.1 ADD_SUBDIRECTORY 指令"></a>6.1.1 ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build&#x2F;src 目录</p></li></ul><h3 id="6-1-2-更改二进制的保存路径"><a href="#6-1-2-更改二进制的保存路径" class="headerlink" title="6.1.2 更改二进制的保存路径"></a>6.1.2 更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}&#x2F;lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="七-安装"><a href="#七-安装" class="headerlink" title="七.安装"></a>七.安装</h1><p><code>INSTALL</code>命令是CMake中用于指定安装规则的命令。它允许你将项目构建生成的文件复制到指定的目录中，以便在安装过程中将这些文件提供给用户或其他项目使用。</p><p><code>INSTALL</code>命令的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>([CODE &lt;code&gt;]</span><br><span class="line">        [SCRIPT &lt;script&gt;]</span><br><span class="line">        [TARGETS &lt;targets&gt;...]</span><br><span class="line">        [FILES &lt;files&gt;...]</span><br><span class="line">        [DIRECTORY &lt;dir&gt;...]</span><br><span class="line">        [PROGRAMS &lt;programs&gt;...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;...]</span><br><span class="line">        [DESTINATION &lt;dir&gt;]</span><br><span class="line">        [PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [OPTIONAL]</span><br><span class="line">        [SET_DESTINATION]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS]</span><br><span class="line">        [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">        [RENAME &lt;name&gt;] [...])</span><br></pre></td></tr></table></figure><p><code>INSTALL</code>命令可以使用多个选项来指定要安装的文件和目录，以及安装的目标路径、权限等。</p><p>以下是一些常用的选项：</p><ul><li><code>TARGETS</code>：指定要安装的目标（可执行文件、库等）。</li><li><code>FILES</code>：指定要安装的文件。</li><li><code>DIRECTORY</code>：指定要安装的目录。</li><li><code>DESTINATION</code>：指定安装的目标路径。</li><li><code>PERMISSIONS</code>：指定安装文件的权限。</li><li><code>COMPONENT</code>：指定安装的组件。</li><li><code>OPTIONAL</code>：指定安装文件是否是可选的。</li><li><code>RENAME</code>：指定安装文件的新名称。</li></ul><p>下面是一个示例，展示如何使用<code>INSTALL</code>命令安装一个可执行文件和一个配置文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义可执行文件和配置文件</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_NAME myapp)</span><br><span class="line"><span class="keyword">SET</span>(CONFIG_FILE myconfig.conf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(<span class="variable">$&#123;EXECUTABLE_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装目标</span></span><br><span class="line"><span class="keyword">INSTALL</span>(TARGETS <span class="variable">$&#123;EXECUTABLE_NAME&#125;</span> DESTINATION bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装文件</span></span><br><span class="line"><span class="keyword">INSTALL</span>(FILES <span class="variable">$&#123;CONFIG_FILE&#125;</span> DESTINATION etc)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了可执行文件的名称（<code>EXECUTABLE_NAME</code>）和配置文件的名称（<code>CONFIG_FILE</code>）。然后，使用<code>ADD_EXECUTABLE</code>命令创建可执行文件。接下来，使用<code>INSTALL</code>命令分别指定可执行文件和配置文件的安装路径。</p><p>在构建项目时，可以使用以下命令将可执行文件和配置文件安装到指定的目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这将构建项目并将可执行文件和配置文件复制到安装路径中。</p><p>请注意，安装路径可以根据你的需求进行调整。你可以根据项目的结构和约定来选择合适的安装路径，并在<code>INSTALL</code>命令中进行相应的修改。</p><p>总之，通过使用CMake的<code>INSTALL</code>命令，你可以指定要安装的文件和目录，并将它们复制到指定的目录中，以供其他项目或系统使用。</p><h2 id="7-1-安装一个Helloworld"><a href="#7-1-安装一个Helloworld" class="headerlink" title="7.1 安装一个Helloworld"></a>7.1 安装一个Helloworld</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 目录树结构</span><br><span class="line">[root@localhost cmake]# tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure><h3 id="7-1-1-安装文件COPYRIGHT和README"><a href="#7-1-1-安装文件COPYRIGHT和README" class="headerlink" title="7.1.1 安装文件COPYRIGHT和README"></a>7.1.1 安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share&#x2F;doc&#x2F;cmake&#x2F;)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 &#x2F;usr&#x2F;local&#x2F;</p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="7-1-2-安装脚本runhello-sh"><a href="#7-1-2-安装脚本runhello-sh" class="headerlink" title="7.1.2 安装脚本runhello.sh"></a>7.1.2 安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 &#x2F;usr&#x2F;bin</p><h3 id="7-1-3-安装-doc-中的-hello-txt"><a href="#7-1-3-安装-doc-中的-hello-txt" class="headerlink" title="7.1.3 安装 doc 中的 hello.txt"></a>7.1.3 安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc&#x2F; DESTINATION share&#x2F;doc&#x2F;cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc&#x2F;有很大的区别</p><p>目录名不以&#x2F;结尾：这个目录将被安装为目标路径下的</p><p>目录名以&#x2F;结尾：将这个目录中的内容安装到目标路径</p><h3 id="7-1-4-安装过程"><a href="#7-1-4-安装过程" class="headerlink" title="7.1.4 安装过程"></a>7.1.4 安装过程</h3><p>cmake ..</p><p>make</p><p>make install</p><h1 id="八-静态库和动态库的构建"><a href="#八-静态库和动态库的构建" class="headerlink" title="八.静态库和动态库的构建"></a>八.静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="8-1-构建实例"><a href="#8-1-构建实例" class="headerlink" title="8.1 构建实例"></a>8.1 构建实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="8-1-1-ADD-LIBRARY"><a href="#8-1-1-ADD-LIBRARY" class="headerlink" title="8.1.1 ADD_LIBRARY"></a>8.1.1 ADD_LIBRARY</h3><p><code>ADD_LIBRARY</code>是CMake中用于添加库的关键字。它用于定义和构建静态库或共享库。</p><p><code>ADD_LIBRARY</code>的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL]</span><br><span class="line">    source1 [source2 ...])</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&lt;name&gt;</code>是要创建的库的名称。</li><li><code>STATIC</code>表示创建一个静态库（<code>.a</code>文件），它在链接时被静态地链接到可执行文件中。</li><li><code>SHARED</code>表示创建一个共享库（<code>.so</code>文件或<code>.dylib</code>文件），它在运行时动态加载。</li><li><code>MODULE</code>表示创建一个模块库（<code>.so</code>文件或<code>.dylib</code>文件），它类似于共享库，但在某些平台上具有不同的用途。</li><li><code>EXCLUDE_FROM_ALL</code>表示将库排除在构建过程之外，不会在默认构建目标中包含。</li><li><code>source</code>表示源文件，这里可以指很多源文件。</li></ul><p>接下来是一个示例，展示如何使用<code>ADD_LIBRARY</code>创建一个静态库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加名为mylib的静态库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(mylib STATIC source1.cpp source2.cpp)</span><br></pre></td></tr></table></figure><p>这将创建一个名为<code>mylib</code>的静态库，其中包含<code>source1.cpp</code>和<code>source2.cpp</code>两个源文件。</p><p>类似地，你也可以创建共享库或模块库。只需将<code>STATIC</code>替换为<code>SHARED</code>或<code>MODULE</code>即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加名为mylib的共享库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(mylib SHARED source1.cpp source2.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加名为mylib的模块库</span></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(mylib MODULE source1.cpp source2.cpp)</span><br></pre></td></tr></table></figure><p>使用<code>ADD_LIBRARY</code>创建库后，你可以使用<code>TARGET_LINK_LIBRARIES</code>命令将库链接到其他目标（如可执行文件）中。这样可以在构建过程中解析库的依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将mylib库链接到myapp可执行文件中</span></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(myapp main.cpp)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(myapp mylib)</span><br></pre></td></tr></table></figure><p>这个示例中，<code>myapp</code>可执行文件将链接到名为<code>mylib</code>的库。</p><p><code>ADD_LIBRARY</code>是CMake中用于创建静态库、共享库或模块库的关键字。它允许你指定库的名称、类型和源文件，并可通过<code>TARGET_LINK_LIBRARIES</code>命令将库链接到其他目标中。</p><h3 id="8-1-2-同时构建静态和动态库"><a href="#8-1-2-同时构建静态和动态库" class="headerlink" title="8.1.2 同时构建静态和动态库"></a>8.1.2 同时构建静态和动态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="8-1-3-SET-TARGET-PROPERTIES"><a href="#8-1-3-SET-TARGET-PROPERTIES" class="headerlink" title="8.1.3 SET_TARGET_PROPERTIES"></a>8.1.3 SET_TARGET_PROPERTIES</h3><p><code>SET_TARGET_PROPERTIES</code>是CMake中用于设置目标属性的命令。通过这个命令，你可以修改目标（如可执行文件、库）的各种属性，如输出路径、编译选项、链接选项、名称等。</p><p><code>SET_TARGET_PROPERTIES</code>的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(target1 target2 ...</span><br><span class="line">    PROPERTIES prop1 value1 prop2 value2 ...)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>target1 target2 ...</code>是要设置属性的目标名称列表。</li><li><code>PROPERTIES</code>关键字用于指定要设置的属性。</li><li><code>prop1 value1 prop2 value2 ...</code>是要设置的属性及其对应的值。</li></ul><p>这里，我们来修改一下库的名称，将静态库和动态库的名称修改一致</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"></span><br><span class="line">//对hello_static的重名为hello</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">//cmake 在构建一个新的<span class="keyword">target</span> 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;source&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="8-1-4-动态库的版本号"><a href="#8-1-4-动态库的版本号" class="headerlink" title="8.1.4 动态库的版本号"></a>8.1.4 动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="8-1-5-安装共享库和头文件"><a href="#8-1-5-安装共享库和头文件" class="headerlink" title="8.1.5 安装共享库和头文件"></a>8.1.5 安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>&#x2F;lib目录，</prefix></p><p>将 hello.h 安装到<prefix>&#x2F;include&#x2F;hello 目录</prefix></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="8-1-6-使用外部共享库和头文件"><a href="#8-1-6-使用外部共享库和头文件" class="headerlink" title="8.1.6 使用外部共享库和头文件"></a>8.1.6 使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
